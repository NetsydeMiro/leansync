(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=global||self,factory(global.leansync={}))})(this,(function(exports){"use strict";function findCorrespondingEntity(entities,entity,keySelector){return entities.find(serverEntity=>keySelector(serverEntity)==keySelector(entity))}function assertNever(x){throw new Error("Unexpected object: "+x)}function isFunction(obj){return obj&&{}.toString.call(obj)==="[object Function]"}const BASIC_CONFLICT_RESOLUTION_STRATEGIES=["takeServer","takeClient","lastUpdated","askClient"];class LeanSyncServer{constructor(config){this.config=config}async sync(clientEntities,lastSynced){return new Promise(async(resolve,reject)=>{var _a,_b,_c,_d,_e,_f;(_b=(_a=this.config).startTransaction)===null||_b===void 0?void 0:_b.call(_a);let syncStamp=new Date;let handledKeys={};let syncResult={syncedEntities:[],newEntities:[],conflictedEntities:[],syncStamp:syncStamp};try{let[serverEntities,serverEntitiesUpdatedSinceLastSync]=await Promise.all([this.config.getServerEntities(clientEntities.map(this.config.entityKey)),this.config.getServerEntitiesSyncedSince(lastSynced)]);for(var clientEntity of clientEntities){let conflictedServerEntity=findCorrespondingEntity(serverEntitiesUpdatedSinceLastSync,clientEntity,this.config.entityKey);if(conflictedServerEntity){if(this.config.areEntitiesEqual(clientEntity,conflictedServerEntity)){syncResult.syncedEntities.push({entity:conflictedServerEntity});handledKeys[this.config.entityKey(clientEntity)]=true}else{if(isFunction(this.config.conflictResolutionStrategy)){this.config.conflictResolutionStrategy(clientEntity,conflictedServerEntity,syncStamp,syncResult);handledKeys[this.config.entityKey(clientEntity)]=true}else{switch(this.config.conflictResolutionStrategy){case"takeClient":let updatedEntity=await this.config.updateServerEntity(clientEntity,syncStamp);syncResult.syncedEntities.push({entity:updatedEntity});break;case"takeServer":syncResult.syncedEntities.push({entity:conflictedServerEntity});break;case"lastUpdated":if(this.config.entityLastUpdated(clientEntity)>this.config.entityLastUpdated(conflictedServerEntity)){let updatedEntity=await this.config.updateServerEntity(clientEntity,syncStamp);syncResult.syncedEntities.push({entity:updatedEntity})}else{syncResult.syncedEntities.push({entity:conflictedServerEntity})}break;case"askClient":syncResult.conflictedEntities.push(conflictedServerEntity);break;default:assertNever(this.config.conflictResolutionStrategy)}handledKeys[this.config.entityKey(clientEntity)]=true}}}else{let serverEntity=findCorrespondingEntity(serverEntities,clientEntity,this.config.entityKey);if(serverEntity){let updatedEntity=await this.config.updateServerEntity(clientEntity,syncStamp);syncResult.syncedEntities.push({entity:updatedEntity})}else{let createdEntity=await this.config.createServerEntity(clientEntity,syncStamp);let clientKey=this.config.entityKey(clientEntity);if(this.config.entityKey(createdEntity)!=clientKey){syncResult.syncedEntities.push({entity:createdEntity,clientKey:clientKey})}else syncResult.syncedEntities.push({entity:createdEntity})}handledKeys[this.config.entityKey(clientEntity)]=true}}for(let serverEntity of serverEntitiesUpdatedSinceLastSync){if(!handledKeys[this.config.entityKey(serverEntity)]){syncResult.newEntities.push(serverEntity)}}(_d=(_c=this.config).commitTransaction)===null||_d===void 0?void 0:_d.call(_c);resolve(syncResult)}catch(ex){(_f=(_e=this.config).rollBackTransaction)===null||_f===void 0?void 0:_f.call(_e);reject(ex)}})}async resolveConflict(resolvedEntity,lastSynced){return new Promise(async(resolve,reject)=>{var _a,_b,_c,_d,_e,_f;let syncStamp=new Date;let result={syncStamp:syncStamp};(_b=(_a=this.config).startTransaction)===null||_b===void 0?void 0:_b.call(_a);try{let serverEntitiesUpdatedSinceLastSync=await this.config.getServerEntitiesSyncedSince(lastSynced);let conflictedAgain=serverEntitiesUpdatedSinceLastSync.find(serverEntity=>this.config.entityKey(serverEntity)==this.config.entityKey(resolvedEntity));if(conflictedAgain){if(!this.config.areEntitiesEqual(resolvedEntity,conflictedAgain)){result.stillRequiringConflictResolution=conflictedAgain}}else await this.config.updateServerEntity(resolvedEntity,syncStamp);(_d=(_c=this.config).commitTransaction)===null||_d===void 0?void 0:_d.call(_c);resolve(result)}catch(ex){(_f=(_e=this.config).rollBackTransaction)===null||_f===void 0?void 0:_f.call(_e);reject(ex)}})}}class ConnectivityError extends Error{}class LeanSyncClient{constructor(config){this.config=config}async sync(){try{let[clientEntities,lastSync]=await Promise.all([this.config.getClientEntitiesRequiringSync(),this.config.getLastSyncStamp()]);clientEntities=clientEntities!==null&&clientEntities!==void 0?clientEntities:[];let syncResult=await this.config.syncWithServer(clientEntities,lastSync);await this.processSyncResponse(syncResult)}catch(ex){if(!(ex instanceof ConnectivityError))throw ex}}async processSyncResponse(syncResult){var _a,_b;for(let newEntity of syncResult.newEntities){await this.config.createEntity(newEntity,syncResult.syncStamp)}for(let modifiedEntity of syncResult.syncedEntities){await this.config.updateEntity(modifiedEntity.entity,syncResult.syncStamp,modifiedEntity.clientKey)}for(let conflictedEntity of syncResult.conflictedEntities){await((_b=(_a=this.config).markRequiringConflictResolution)===null||_b===void 0?void 0:_b.call(_a,conflictedEntity,syncResult.syncStamp))}await this.config.markSyncStamp(syncResult.syncStamp)}}exports.BASIC_CONFLICT_RESOLUTION_STRATEGIES=BASIC_CONFLICT_RESOLUTION_STRATEGIES;exports.ConnectivityError=ConnectivityError;exports.LeanSyncClient=LeanSyncClient;exports.LeanSyncServer=LeanSyncServer;Object.defineProperty(exports,"__esModule",{value:true})}));